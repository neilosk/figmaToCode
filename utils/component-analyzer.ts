import { ProcessedNode } from '../types/figma';

/**
 * Categories for meaningful components
 */
export enum ComponentCategory {
  LAYOUT = 'layout',
  FORM = 'form', 
  NAVIGATION = 'navigation',
  BUTTON = 'button',
  ICON = 'icon',
  DATA_DISPLAY = 'data-display',
  BUSINESS_LOGIC = 'business-logic',
  UI_COMPONENT = 'ui-component'
}

export interface AnalyzedComponent {
  node: ProcessedNode;
  category: ComponentCategory;
  meaningfulName: string;
  cleanName: string;
  complexity: 'low' | 'medium' | 'high';
  description: string;
  recommendedForGeneration: boolean;
  childCount: number;
  hasInteractivity: boolean;
}

/**
 * Analyzes and filters Figma components to identify meaningful ones for generation
 */
export class ComponentAnalyzer {
  
  /**
   * Analyze all nodes and return meaningful components categorized and ranked
   */
  static analyzeComponents(nodes: ProcessedNode[]): AnalyzedComponent[] {
    const analyzed: AnalyzedComponent[] = [];
    
    // Recursively find all components
    const findAllComponents = (node: ProcessedNode) => {
      if (node.isComponent && this.isMeaningfulComponent(node)) {
        analyzed.push(this.analyzeComponent(node));
      }
      
      if (node.children) {
        node.children.forEach(findAllComponents);
      }
    };
    
    nodes.forEach(findAllComponents);
    
    // Sort by recommendation score and category
    return analyzed.sort((a, b) => {
      if (a.recommendedForGeneration !== b.recommendedForGeneration) {
        return a.recommendedForGeneration ? -1 : 1;
      }
      return a.category.localeCompare(b.category);
    });
  }
  
  /**
   * Determine if a component is meaningful (not auto-generated)
   */
  private static isMeaningfulComponent(node: ProcessedNode): boolean {
    const name = node.name || node.componentName || '';
    
    // Skip auto-generated names
    if (this.isAutoGeneratedName(name)) return false;
    
    // Skip very generic names
    if (this.isGenericName(name)) return false;
    
    // Skip single characters or very short names (except meaningful ones)
    if (name.length <= 2 && !['UI', 'CTA', '+'].includes(name)) return false;
    
    // Must have some content or meaningful children
    if (!node.content && (!node.children || node.children.length === 0)) return false;
    
    return true;
  }
  
  /**
   * Check if name is auto-generated by Figma
   */
  private static isAutoGeneratedName(name: string): boolean {
    const autoGenPatterns = [
      /^Frame \d+/,
      /^Rectangle \d+/,
      /^Ellipse \d+/,
      /^Path \d+/,
      /^Vector \d+/,
      /^Group \d+/,
      /^Component \d+/,
      /^Instance \d+/
    ];
    
    return autoGenPatterns.some(pattern => pattern.test(name));
  }
  
  /**
   * Check if name is too generic
   */
  private static isGenericName(name: string): boolean {
    const genericNames = [
      'text', 'image', 'shape', 'layer', 'element', 'item', 'container',
      'wrapper', 'box', 'div', 'span', 'section'
    ];
    
    return genericNames.includes(name.toLowerCase());
  }
  
  /**
   * Analyze individual component and categorize it
   */
  private static analyzeComponent(node: ProcessedNode): AnalyzedComponent {
    const name = node.name || node.componentName || '';
    const cleanName = this.generateCleanName(name);
    const category = this.categorizeComponent(name, node);
    const complexity = this.assessComplexity(node);
    const childCount = node.children ? node.children.length : 0;
    const hasInteractivity = this.hasInteractiveElements(node);
    
    return {
      node,
      category,
      meaningfulName: name,
      cleanName,
      complexity,
      description: this.generateDescription(name, category, node),
      recommendedForGeneration: this.isRecommendedForGeneration(category, complexity, node),
      childCount,
      hasInteractivity
    };
  }
  
  /**
   * Generate clean component name for code generation
   */
  private static generateCleanName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9\s]/g, '') // Remove special chars
      .replace(/\s+/g, ' ') // Normalize spaces
      .trim()
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
  
  /**
   * Categorize component based on name and structure
   */
  private static categorizeComponent(name: string, node: ProcessedNode): ComponentCategory {
    const lowerName = name.toLowerCase();
    
    // Form components
    if (/input|field|form|checkbox|radio|toggle|search|button/.test(lowerName)) {
      if (/button|btn|cta/.test(lowerName)) return ComponentCategory.BUTTON;
      return ComponentCategory.FORM;
    }
    
    // Navigation
    if (/nav|menu|breadcrumb|scrollspy|stepper/.test(lowerName)) {
      return ComponentCategory.NAVIGATION;
    }
    
    // Icons
    if (/icon|functional/.test(lowerName) || /^[A-Z][a-z]* \//.test(name)) {
      return ComponentCategory.ICON;
    }
    
    // Layout components
    if (/grid|layout|container|wrapper|header|footer|sidebar/.test(lowerName)) {
      return ComponentCategory.LAYOUT;
    }
    
    // Business logic components
    if (/product|advisor|banking|digital|nbg|logo/.test(lowerName)) {
      return ComponentCategory.BUSINESS_LOGIC;
    }
    
    // Buttons and CTAs
    if (/button|btn|cta|accept|reject/.test(lowerName)) {
      return ComponentCategory.BUTTON;
    }
    
    // Data display
    if (/list|grid|table|card|item|display/.test(lowerName)) {
      return ComponentCategory.DATA_DISPLAY;
    }
    
    // Default to UI component
    return ComponentCategory.UI_COMPONENT;
  }
  
  /**
   * Assess component complexity
   */
  private static assessComplexity(node: ProcessedNode): 'low' | 'medium' | 'high' {
    const childCount = node.children ? node.children.length : 0;
    const hasNestedStructure = node.children?.some(child => child.children && child.children.length > 0);
    const hasComplexStyling = Object.keys(node.styles || {}).length > 5;
    
    if (childCount > 10 || hasNestedStructure) return 'high';
    if (childCount > 3 || hasComplexStyling) return 'medium';
    return 'low';
  }
  
  /**
   * Check if component has interactive elements
   */
  private static hasInteractiveElements(node: ProcessedNode): boolean {
    const name = (node.name || '').toLowerCase();
    
    // Check for interactive keywords
    if (/button|click|hover|toggle|input|select|checkbox|radio/.test(name)) return true;
    
    // Check children for interactive elements
    if (node.children) {
      return node.children.some(child => this.hasInteractiveElements(child));
    }
    
    return false;
  }
  
  /**
   * Generate human-readable description
   */
  private static generateDescription(name: string, category: ComponentCategory, node: ProcessedNode): string {
    const childCount = node.children ? node.children.length : 0;
    const size = node.styles?.width && node.styles?.height ? 
      `${node.styles.width}x${node.styles.height}px` : 'auto';
    
    const categoryDescriptions = {
      [ComponentCategory.FORM]: 'Form input or control element',
      [ComponentCategory.BUTTON]: 'Interactive button or call-to-action',
      [ComponentCategory.NAVIGATION]: 'Navigation or menu component',
      [ComponentCategory.ICON]: 'Icon or visual indicator',
      [ComponentCategory.LAYOUT]: 'Layout or structural component', 
      [ComponentCategory.DATA_DISPLAY]: 'Data display or list component',
      [ComponentCategory.BUSINESS_LOGIC]: 'Business-specific feature component',
      [ComponentCategory.UI_COMPONENT]: 'User interface element'
    };
    
    const baseDescription = categoryDescriptions[category];
    const details = childCount > 0 ? ` with ${childCount} child elements` : '';
    const sizeInfo = size !== 'auto' ? ` (${size})` : '';
    
    return `${baseDescription}${details}${sizeInfo}`;
  }
  
  /**
   * Determine if component is recommended for generation
   */
  private static isRecommendedForGeneration(
    category: ComponentCategory, 
    complexity: string, 
    node: ProcessedNode
  ): boolean {
    // High priority categories
    const highPriorityCategories = [
      ComponentCategory.FORM,
      ComponentCategory.BUTTON, 
      ComponentCategory.NAVIGATION,
      ComponentCategory.BUSINESS_LOGIC
    ];
    
    // Don't recommend overly complex components for single generation
    if (complexity === 'high') return false;
    
    // Don't recommend pure icons for individual generation
    if (category === ComponentCategory.ICON) return false;
    
    // Must have some meaningful content
    const hasContent = node.content || (node.children && node.children.length > 0);
    if (!hasContent) return false;
    
    // Prioritize high-value categories
    if (highPriorityCategories.includes(category)) return true;
    
    // Include medium complexity UI components
    if (complexity === 'medium' && category === ComponentCategory.UI_COMPONENT) return true;
    
    return false;
  }
  
  /**
   * Group components by category for UI display
   */
  static groupByCategory(components: AnalyzedComponent[]): Record<ComponentCategory, AnalyzedComponent[]> {
    const grouped: Record<ComponentCategory, AnalyzedComponent[]> = {
      [ComponentCategory.BUSINESS_LOGIC]: [],
      [ComponentCategory.FORM]: [],
      [ComponentCategory.BUTTON]: [],
      [ComponentCategory.NAVIGATION]: [],
      [ComponentCategory.DATA_DISPLAY]: [],
      [ComponentCategory.LAYOUT]: [],
      [ComponentCategory.UI_COMPONENT]: [],
      [ComponentCategory.ICON]: []
    };
    
    components.forEach(component => {
      grouped[component.category].push(component);
    });
    
    return grouped;
  }
}